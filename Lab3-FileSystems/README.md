# Описание лабы
1. Написать программу, которая копирует каталог “задом наперед”. Программа получает в качестве аргумента путь к каталогу. Далее:
	1. a. Программа создает каталог с именем заданного каталога, прочитанного наоборот. Если задан каталог “qwerty”, то должен быть создан каталог “ytrewq”. 
	2. b. Программа копирует все регулярные файлы из исходного каталога в целевой (пропуская файлы другого типа), переворачивая их имена и содержимое. То есть с именами файлов поступаем также как и с именем каталога, а содержимое копируется начиная с последнего байта и до нулевого. 
2. Написать программу, которая создает, читает, изменяет права доступа и удаляет следующие объекты: файлы, каталоги, символьные и жесткие ссылки. Для определения того какая именно функция должна быть исполнена предлагается иметь необходимое количество жестких ссылок на исполняемый файл с именами соответствующими выполняемому действию и в программе выполнять функцию соответствующую имени жесткой ссылки. Программа должна уметь: 
	1. a. создать каталог, указанный в аргументе; 
	2. b. вывести содержимое каталога, указанного в аргументе; 
	3. c. удалить каталог, указанный в аргументе; 
	4. d. создать файл, указанный в аргументе; 
	5. e. вывести содержимое файла, указанного в аргументе; 
	6. f. удалить файл, указанный в аргументе; 
	7. g. создать символьную ссылку на файл, указанный в аргументе; 
	8. h. вывести содержимое символьной ссылки, указанный в аргументе; 
	9. i. вывести содержимое файла, на который указывает символьная ссылка, указанная в аргументе; 
	10. j. удалить символьную ссылку на файл, указанный в аргументе; 
	11. k. создать жесткую ссылку на файл, указанный в аргументе; 
	12. l. удалить жесткую ссылку на файл, указанный в аргументе; 
	13. m. вывести права доступа к файлу, указанному в аргументе и количество жестких ссылок на него; 
	14. n. изменить права доступа к файлу, указанному в аргументе. 
3. Написать программу, которая выводит содержимое /proc/pid/pagemap

Прежде чем запускать task2 файл, создайте hardlink для каждой команды с соответствующим именем команды через ln task1.exe command_name

# Лекции
/ - корень 
относительно текущей директории - относительный путь
относительно корня - абсолютный путь 

через mount можно примонтировать другую файловую систему
/flash -> флешка(ее корень /)

в UNIX единая файловая система, в нее встраиваем конкретные файловые системы

/ - точка монтирования(на ххд уже находятся bin, etc)

Файловая система - то как организованы файлы
FS driver - сами алгоритмы по работе со storage (интерфейс, мы не видим что находится ниже, там может быть хоть сетевая среда, мы видим только команды как с этим работать )

на каком то файле data (не обьяснил что это ) создали файловую систему через

```
mkfs.ext4 ./data

//у нас есть луп девайсы
//loop устройство может вести себя как виртуальная файловая система

//узнаем свободный 
losetup -f
sudo losetup /путь/свободного/loop ./data
losetup /путь/нашего/loop //выведеи с чем связан
//теперь мы хотим создать точку монтирования - католог
mkdir dir

sudo mount /путь/нашего/loop ./dir
//идем в dir
cd ./dir
ls -l
//будет католог lost+found создается при ext4
//теперь если мы что то создаем то оно лежит в data

//если убрать точку монтирования 
sudo unmount ./dir
ls -l //выведет то что было изначально до создания точки монтирования без изменений
```
между нашей / и какой то файловой системой есть VFS ( как раз тот loop)

и каждая файловая система должна уметь предоставить VFS конкретную структуру inode

Что происходит когда мы допустим хотим открыть файл по пути

/home/.../.../
система же сначала должна понять есть ли у нас этот home или нет, а если есть то директория это или файл

у нас есть directory_entry (dentry) и inode


```Dentry
Dentry: //описывает элемент пути

name: "/"
*inode //нет имени файла потому что на один инод может ссылаться несколько дентри
*parent_dentry = NULL (потому что выше / нет ничего) //последующие дентри будут указывать на предыдущий(который выше)
```

```
Inode

//содержит всю информацию о обьекте
meta:
	owner 
	type
	mode
	...
funcs

```

функция lookup вернет dentry нашего проверяемого файла есть он есть в inode

полученный дентри кэшируется


struct dirent {
    ino_t          d_ino;     // inode number
    off_t          d_off;     // смещение до следующей записи (не всегда используется)
    unsigned short d_reclen;  // длина этой записи
    unsigned char  d_type;    // тип файла (DT_REG, DT_DIR и т.д.)
    char           d_name[];  // имя файла (null-terminated)
};


| Значение     | Описание                            |
| ------------ | ----------------------------------- |
| `DT_REG`     | Обычный файл                        |
| `DT_DIR`     | Каталог                             |
| `DT_LNK`     | Символическая ссылка                |
| `DT_FIFO`    | Именованный канал                   |
| `DT_SOCK`    | Сокет                               |
| `DT_CHR`     | Символьное устройство               |
| `DT_BLK`     | Блочное устройство                  |
| `DT_UNKNOWN` | Тип неизвестен (иногда так бывает!) |
|              |                                     |

# Теория в общем

Файл — это набор данных, хранящийся на диске или другом носителе, который ОС рассматривает как единицу хранения информации.

### Основные свойства файла:
- **Имя файла** (например, document.txt)
- **Тип файла** (обычный, каталог, устройство и т. д.)
- **Размер** (в байтах)
- **Владелец и права доступа** (chmod, chown)
- **Метаданные** (время создания, изменения)
- **Содержимое** (данные в виде байтов)

### Типы файлов:
1. **Обычные файлы (regular files)**  
   Могут содержать текст, код, изображения (.txt, .jpg, .c, a.out)
   
2. **Каталоги (директории) (directories)**  
   Хранят список файлов и других директорий. Например: /home/user/, /etc/
   
3. **Символические ссылки (symbolic links)**  
   Указывают на другой файл или каталог. Работают как ярлыки.
   
4. **Специальные файлы (устройства)**  
   Файлы устройств (/dev/sda, /dev/null)  
   Два типа: блочные (диски) и символьные (терминалы).
   
5. **FIFO (именованные каналы) и сокеты**  
   Используются для межпроцессного взаимодействия.

### Права доступа
Права доступа состоят из 10 символов. Первый указывает на тип файла, а остальные 9 разделены на 3 группы по 3 символа.

### Файловая система (ФС)
Файловая система (ФС) — это метод организации и хранения данных на диске. Она управляет файлами, их расположением, доступом и метаданными.

#### Что делает файловая система?
1. Определяет структуру хранения:  
   ФС решает, как файлы записываются, читаются, изменяются.
   
2. Работает с каталогами:  
   ФС позволяет организовывать файлы в иерархические структуры (/home/user/docs/).
   
3. Управляет доступом:  
   Кто может читать/писать файл (chmod, chown).
   
4. Следит за использованием места:  
   ФС следит, какие блоки на диске заняты, а какие свободны.
   
5. Обеспечивает защиту от сбоев:  
   Журналирование (ext3/ext4) помогает восстанавливать файлы после ошибок.

### Физическая файловая система (FS)
Каждая ФС использует структуры данных для работы с файлами:
- **Superblock** — информация о ФС (размер, состояние, свободные блоки).
- **Inode Table** — метаданные файлов (размер, права, ссылки).
- **Data Blocks** — где хранятся сами данные файлов.
- **Dentry (Directory Entry)** — связывает имена файлов с inode.

### Виды файловых систем
1. **Файловые системы в Linux**
   - ext4 (стандартная в Linux) — журналируемая, быстрая, устойчивая.
   - XFS (Red Hat) — хороша для больших файлов.
   - Btrfs (новая) — поддержка снапшотов и самовосстановления.
   
2. **Файловые системы в Windows**
   - NTFS (основная) — поддерживает права доступа, шифрование.
   - FAT32 (старый стандарт) — работает в Windows, Linux, macOS, но ограничен 4 ГБ на файл.
   
3. **Файловые системы для флешек**
   - exFAT — лучше FAT32, поддерживает большие файлы.
   - FAT32 — совместимость, но ограничение на размер файлов (4 ГБ).

### Виртуальная файловая система (VFS)
VFS (Virtual File System) — виртуальная файловая система  
VFS — это абстрактный интерфейс ядра, позволяющий работать с файлами независимо от конкретной файловой системы (ext4, NTFS, FAT32). Он позволяет программе работать с файлами единым способом, даже если файлы хранятся на разных носителях.

#### Как взаимодействуют VFS и реальная файловая система?
1. Программа вызывает open("/home/user/file.txt").
2. VFS принимает вызов и проверяет кеш открытых файлов.
3. VFS парсит путь /home/user/file.txt и ищет его в кешах dentry и inode.
4. Если в кеше нет, VFS спрашивает файловую систему (например, ext4).
5. Файловая система ext4 ищет файл на диске, проверяя каталог /home/user/.
6. Каталог /home/user/ – это просто таблица (dentry), в которой записано, что file.txt связан с inode 1234.
7. Файловая система возвращает inode 1234, и VFS кэширует его.
8. Теперь программа может read() данные, а VFS через драйвер передаёт запрос в ext4, которая читает блоки данных с диска.
9. Когда программа закрывает файл (close()), VFS освобождает кеши и уведомляет файловую систему.

### VDFS (Virtual Distributed File System)
VDFS — это виртуальная распределённая файловая система.  
Она позволяет объединить несколько различных файловых систем или устройств хранения в единое логическое файловое пространство. Это особенно полезно в облачных системах, кластерах и сетевых хранилищах.

#### Пример использования VDFS:
Допустим, у тебя есть:  
- Локальный диск (/mnt/local/)  
- Сетевое хранилище (/mnt/nas/)  
- Облачное хранилище (Google Drive, S3)  

VDFS создаёт единый каталог /mnt/vdfs/, в котором файлы из всех этих мест выглядят как единая структура.

### procfs (процессная файловая система, /proc)
procfs — это виртуальная файловая система, которая предоставляет доступ к информации о процессах и состоянии системы в виде файлов.  
- Это НЕ обычная файловая система, потому что файлы в ней не занимают место на диске – они создаются динамически в памяти.
- Используется для взаимодействия с ядром Linux. Находится в /proc и позволяет читать данные ядра как файлы.

#### Как они взаимодействуют?
1. Ты запускаешь команду `ls /home/user`.
2. VFS принимает команду, обрабатывает её и передает дальше.
3. VFS решает, какая файловая система отвечает за /home/user.
4. Если это локальный диск → VFS передает запрос в ext4 (или другую ФС).
5. Если это сетевой ресурс → VFS использует VDFS (например, NFS).
6. Если это информация о процессах → запрос идет в procfs.

### Файловая система Linux использует две важные структуры для работы с файлами:
1. **inode (индексный дескриптор)** — хранит информацию о файле.
2. **dentry (структура каталога)** — связывает имя файла с его inode.

#### 1. inode — индексный дескриптор файла
Каждый файл в Linux описывается уникальным inode (индексным узлом). Это структура данных, которая хранит метаданные файла, но не его имя.

##### Что хранит inode?
- Размер файла (в байтах).
- Владелец и группа (UID, GID).
- Права доступа (rwx для владельца, группы, других).
- Временные метки (ctime, mtime, atime).
- Список блоков на диске, где хранятся данные файла.
- Количество жёстких ссылок (hard links).

##### inode не хранит имя файла.
Один файл может иметь несколько имён, благодаря hard links. Это работает потому, что имя файла и его данные хранятся отдельно:
- Имена файлов хранятся в dentry (записях каталога).
- Метаданные и указатели на данные хранятся в inode.

##### Как создать жёсткую ссылку?
Используется команда `ln` без флага `-s`:  
```bash
ln file1.txt file2.txt
```

##### Как это выглядит в файловой системе?
Допустим, у нас есть файл `file1.txt`:  
```
file1.txt  → [dentry] → [inode #1234] → [данные на диске]
```

После создания жёсткой ссылки:  
```
file1.txt  → [dentry] ─┐
                        ├──> [inode #1234] → [данные на диске]
file2.txt  → [dentry] ─┘
```

Теперь у нас два имени (`file1.txt` и `file2.txt`), но они оба указывают на один и тот же inode.

##### Каждый inode хранит счетчик ссылок (сколько имён на него указывают).
Можно проверить это с помощью команды `ls -l`:  
```
-rw-r--r-- 2 user user 100  мар 27 12:00 file1.txt
-rw-r--r-- 2 user user 100  мар 27 12:00 file2.txt
```

Здесь "2" в первой колонке означает, что этот inode имеет две ссылки.

##### Что происходит при удалении одной ссылки?
Если удалить `file1.txt`:  
```bash
rm file1.txt
```

Файл не удалится сразу, потому что у inode всё ещё есть вторая ссылка (`file2.txt`).  
После удаления последней ссылки (`file2.txt`), inode будет освобождён, и данные файла будут окончательно удалены.

#### Вопрос: у меня есть файл и один поток начинает его читать, а второй удаляет. что будет? сможем ли мы продолжить чтение?
Ответ: Да, поток, читающий файл, сможет продолжить чтение даже после его удаления другим потоком.

##### Почему так происходит?
В Linux (и Unix-подобных системах) удаление файла с помощью `rm` или `unlink()` не сразу освобождает его данные на диске.  
Файл удаляется из каталога (то есть удаляется его имя в dentry), но его содержимое остаётся в системе, пока хотя бы один процесс держит его открытым.

#### 2. dentry — запись в каталоге (directory entry)
dentry связывает имя файла с его inode.  
Каталог в Linux – это просто список dentry, указывающих на inode.

##### Что хранит dentry?
- Имя файла (например, file.txt).
- Ссылка на inode, который описывает файл.
- Флаги состояния (активен ли, в кеше ли).
- Ссылку на родительский каталог (чтобы понимать структуру).

#### Как inode и dentry работают вместе?
1. Открытие файла: ФС ищет имя файла (dentry) в каталоге.
2. По dentry получает inode.
3. inode указывает, где на диске лежат данные файла.
4. ФС читает данные из этих блоков.

#### Пример
```bash
echo "Hello" > /home/user/file.txt
cat /home/user/file.txt
```

Каталог `/home/user/` содержит dentry для `file.txt`.  
Этот dentry указывает на inode с метаданными файла.  
По inode ФС находит блоки с данными на диске.  
Читаем `Hello` из файла.

#### Функции open() и close() в Linux (и UNIX-подобных системах)
open() – это системный вызов, который сообщает ядру, что процесс хочет работать с файлом.  
read() читает данные из файла, используя файловый дескриптор.  
write() записывает данные в файл.  
close() закрывает файловый дескриптор и освобождает ресурсы ядра.

##### Что происходит на уровне ядра?
Когда вызываем `open("file.txt", O_RDONLY);`
1. Проверяется путь файла (`file.txt`).
2. VFS (Virtual File System) ищет `file.txt` в соответствующей файловой системе (ext4, NTFS и т. д.).
3. Создается запись в dentry cache (кэш имен файлов).
4. Считывается inode файла (метаданные файла).
5. Ядро выделяет файловый дескриптор (например, 3).

Когда вызываем `read(fd, buffer, 128);`
1. Проверяется, есть ли fd в таблице открытых файлов процесса.
2. Находится inode файла через dentry.
3. Читаются данные из кеша страницы или с диска.
4. Записываются в buffer программы.

Когда вызываем `close(fd);`
1. Удаляется запись о файле из таблицы открытых файлов процесса.
2. Ядро проверяет, есть ли другие процессы, которые используют этот файл.
3. Если нет – inode освобождается, дескриптор удаляется.

