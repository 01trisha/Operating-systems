
# Требования

Компиляция, сборка, запуск 
1. Написать программу hello.c, которая выводит фразу “Hello world”: 
	a. получить исполняемый файл; 
	b. посмотреть unresolved symbols (puts, printf) с помощью nm; 
	c. посмотреть зависимости (ldd); 
	d. запустить. 
2. Написать статическую библиотеку с функцией hello_from_static_lib() и использовать ее в hello.c: 
	a. посмотреть исполняемый файл на предмет того будет ли функция hello_from_static_lib() unresolved. Почему? 
	b. где находится код этой функции? 
3. Написать динамическую библиотеку с функцией hello_from_dynamic_lib() и использовать ее с hello.c: 
	a. посмотреть состояние функции hello_from_dynamic_lib в получившимся исполняемом файле. Объяснить увиденное.

# Реализация и теория
### 1.1
```
nm -u hello_world.out
```
nm -u hello_world.out
выводит неразрешенный символ(функция которая используется но не описана)
поэтому чтоб увидеть зависимость у нас 
```
otool -L hello_world.out
```

### 1.2
```
gcc -c libstatic.c -o libstatic.o
//компиляция до линковки 
ar r libstatic.a libstatic.o
//создаем статическую библиотеку .a с обьектным файлом .o
gcc hello_world.c -L. -lstatic -o hello_world
//компилируем .c с указанием что библиотека в текущей директории
rm *.o

clean:

rm -f *.o *.a hello_world
```

### 1.3
```Makefile
compile:
	cd lib/ &&	gcc -shared -fPIC -o libdynamic.so libdynamic.c
	cd ..
	gcc -o hello hello.c \
	> -L./lib/ -ldynamic -Wl,-rpath,/home/parallels/Desktop/lab1/dynamic_lib/lib/
	./hello
...
```

```
gcc -shared -fPIC -o libdynamic.so libdynamic.c
```

компилируем библиотеку
-shared: указываем что нужно создать динамическую библиотеку(.so)
-fPIC: генерируем позиционно-независимый код чтоб можно было библиотеку загружать в любое место в памяти 
-L./lib/: указываем компилятору где искать библиотеки
-Wl,-rpath,/home/parallels/Desktop/lab1/dynamic_lib/lib/:
	-Wl передаем опции линкеру
	-rpath... указываем линкеру где искать библиотеку во время выполнения программы

- readelf -S — вывести список секций
- readelf -l — вывести программные заголовки (сегменты).

Сегменты управляют загрузкой секций в память и их доступностью (чтение/запись/исполнение).
Секции видны только в файле ELF и не обязательно загружаются в память при выполнении программы.

## Что происходит когда запускаем программу и чем пользуемся
### Что происходит?:
- ОС ищет исполняемый файл
	- есть абсолютный путь
	- относительный путь(относительно текущей директории)
- Или используем команду с именем программы - в ход идет PATH
- Ядро загружает в память elf файл
- Разбор elf файла с помощью загрузчика(loader'a):
	- заголовок говорит как загружать именно файл
	- сегменты которые содержат код программы, данные 
	- ...
- Поиск интерпретатора и его запуск(если он требуется)
-  Создается новый процесс в ос - запуск программы(процесса)
- Подгрузка динамических библиотек(LD_LIBRARY_PATH)

### Чем пользуемся?:
- Путь к exe
- ELF файл
- PATH
- Сегменты и секции ELF
- LD_LIBRARY_PATH
## Права
r - read
w - write
x - execute
p - private, изменения не отобразятся в файле
s- shared, изменения могут отобразиться в файле
## Где находится адрес динам библиотеки и где начало
.text r-xp - код программы(библиотеки) испольняется, не изменяется
---p временный промежуток для защиты памяти
.rodata r--p - константы и строки, просто читается
.bss .data - глобальные и статические данные - доступна запись

Да, процесс загрузки исполнимого файла (в формате ELF) в память связан с несколькими этапами, которые определяют, куда и как загружается содержимое. Рассмотрим, как это происходит и почему существуют различные сегменты и секции в ELF-файле.

## Как загрузчик находит адреса виртуальной функции

### Как ELF-файл загружается в память:

1. **Чтение ELF-файла**:
   Когда вы запускаете исполнимый файл, загрузчик (например, `ld-linux.so` на Linux) первым делом читает ELF-файл, который состоит из заголовков и разных разделов данных, такие как заголовок ELF, таблица программных заголовков, сегменты и секции.

2. **Таблица программных заголовков**:
   В ELF-файле есть **таблица программных заголовков** (Program Header Table), которая описывает, как загрузить различные **сегменты** (segments) из файла в память. Каждый сегмент представляет собой область памяти, которую нужно загрузить в определенное место.

3. **Сегменты ELF-файла**:
   Сегменты — это части исполнимого файла, которые содержат код, данные и другие области, необходимые для выполнения программы. Когда загрузчик читает ELF-файл, он размещает эти сегменты в определенные области памяти.
   
   Например:
   - **Сегмент `.text`**: содержит исполняемый код программы.
   - **Сегмент `.data`**: содержит инициализированные глобальные переменные.
   - **Сегмент `.bss`**: содержит неинициализированные глобальные переменные (при загрузке такие переменные инициализируются нулями).
   
4. **Динамическая загрузка библиотек**:
   Для динамических библиотек (например, `libc.so`) в ELF-файле имеется специальный раздел, указывающий на зависимость от этих библиотек. Загрузчик будет искать и загружать необходимые библиотеки в память. Обычно они загружаются в том месте, где их можно безопасно использовать (в виртуальном адресном пространстве процесса).

5. **Разрешение символов**:
   После того как сегменты загружены в память, загрузчик также решает **символьные зависимости**. Это означает, что символы (например, функции или переменные), которые были объявлены в динамических библиотеках, связываются с адресами в памяти. Это необходимая операция для работы с такими библиотеками.

6. **Подготовка стека и кучи**:
   После загрузки сегментов и библиотек загрузчик настраивает **стек** (для хранения локальных переменных и вызова функций) и **кучу** (для динамически выделяемой памяти, например, с помощью `malloc`).

7. **Передача управления процессу**:
   После того как все эти операции завершены, управление передается в начало программы, и процесс начинает выполняться.

### Почему в ELF-файле так много сегментов и секций?

Каждый сегмент и секция в ELF-файле выполняет свою специфическую роль. Вот зачем они нужны:

1. **Сегменты** (в отличие от секций) относятся непосредственно к процессу загрузки и управлению памятью. Они содержат данные, которые будут размещены в памяти и использоваться во время выполнения программы. Сегменты могут быть:
   - **Исполняемыми** (например, код программы).
   - **Читаемыми и записываемыми** (например, инициализированные данные).
   - **Только читаемыми** (например, константы или строки).

2. **Секции** используются для хранения информации, которая нужна компилятору и другим инструментам на разных этапах компиляции и линковки, но не обязательно будет загружена в память. Например:
   - **`.text`** — хранит исполняемый код.
   - **`.data`** — хранит инициализированные глобальные переменные.
   - **`.bss`** — хранит неинициализированные глобальные переменные.
   - **`.rodata`** — хранит только для чтения данные, такие как строки.
   - **`.symtab`** — таблица символов, используемая компилятором и линковщиком.

3. **Требования безопасности**:
   Современные операционные системы используют множество сегментов для реализации различных механизмов безопасности. Например:
   - **NX (No-eXecute)** — сегменты могут быть помечены как исполнимые или неисполнимые, чтобы предотвратить выполнение данных (например, стек или куча не должны содержать исполнимый код).
   - **ASLR (Address Space Layout Randomization)** — размещение различных сегментов в случайных местах в памяти для предотвращения атак на программу.

4. **Разделение и оптимизация**:
   - Сегменты и секции могут быть разделены для оптимизации работы программы. Например, некоторые сегменты могут быть **только для чтения** (что улучшает производительность за счет использования кэширования) или **только для записи** (например, для динамически выделяемых данных).
   - Сегменты с кодом могут быть защищены от записи для предотвращения изменений, а данные могут быть защищены от выполнения.

### Пример работы с сегментами и секциями:

Когда вы запускаете программу, загрузчик загружает сегменты из ELF-файла в память, размещая код программы в одном месте, данные в другом, и выполняет все необходимые настройки. Все это нужно для того, чтобы программа могла работать корректно, использовать библиотеки, а также поддерживать безопасность и производительность.

Таким образом, количество и типы сегментов и секций в ELF-файле связаны с необходимостью разделения различных типов данных, кодов и метаданных, что позволяет операционной системе эффективно загружать, защищать и исполнять программы.