## Системные вызовы 
1. Проведите следующие эксперименты: a. запустите программу hello world из предыдущей задачи под strace: 
		i. обратите внимание какие системные вызовы были вызваны в процессе исполнения программы. Чем обусловлено такое количество системных вызовов. Какой системный вызов используется для вывода “hello world”? Изучите этот вызов и разберитесь что он принимает и возвращает. 
		ii. используйте этот сискол в программе hello world вместо printf(). Убедитесь что этот вызов присутствует в выводе strace.
		iii. напишите свою обертку над этим сисколом. Для этого используйте функцию syscall() из libc. Также проверьте вывод strace. b. Запустите под strace команду ‘wget kernel.org’ (если нет wget, используйте curl). Получите статистику использования системных вызовов порожденным процессом.
2. Разберитесь как устроена функция syscall(). Напишите код, который напечатает hello world без использования функции syscall(). 
3. Разберитесь как работает системный вызов ptrace(2) и напишите программу, которая породит процесс и выведет все системные вызовы дочернего процесса. (Можно решить эту задачу после изучения темы “Процессы”).

## Реализация

```q
    .global _start

    .section .data
msg:    .asciz "Hello, world!\n"
len = . - msg

    .section .text
_start:
    //system call write
    mov x0, 1
    ldr x1, =msg
    mov x2, len
    mov x8, 64 //number of system call of write
    svc #0

   mov x0, 0 
   mov x8, 93
   svc #0
```

- Ассемблерный код с прямым вызовом прерывания(его номера)
- что происходит при запуске?:
	1. ... устанавливаем все регистры итд
	2. mov x8, 64 - устанавливаем номер системного вызова write
	3. svc #0 передаем ядру выполнение write(переходим в превилегированный режим для записи в stdout строки)
	4. mov x0, 0  - устанавливаем код возврата
	5. mov x8, 93 - устанавливаем номер сис вызова exit
	6. svc #0 - передаем управление ядру для завершения программы
- почему не напрямую?:
	- если бы не было механизма системных вызовов то процессу пришлось бы работать без защиты, управлять устройствами напрямую. вместо этого ядро предоставляет системные вызовы ограничивая доступ к ресурсам и обеспечивая безопасность
	- svc как переключатель между пользовательским и привилигерованным режимами так так пользовательские процессы работают в пользовательском пространстве

**`svc #0`** (supervisor call) - инструкция используется для вызова системных функций (выполнения системных вызовов)
переводит процесс из пользовательского режима в привилегированный
#0 - базовая инструкция прерывания

1. из пользовательского в привилегированный
2. обработчик прерываний - процессор генерирует исключение которое переключает выполнение на обработчик
3. система проверяет какой номер системного вызова был записан и выполняет его 
4. переход в пользовательский режим
